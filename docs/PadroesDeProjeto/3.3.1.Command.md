# 3.3.1. Command

## Introdução

Este documento apresenta o padrão de projeto comportamental **Command**, conforme descrito pelo Gang of Four (GoF), e sua aplicação prática em um sistema de gerenciamento de usuários para adoção e doação de pets, construído com Ruby on Rails e PostgreSQL.

O padrão **Command** tem como objetivo encapsular uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações, enfileirar ou registrar ações e oferecer suporte a operações desfazíveis. Ele atua como um intermediário entre o chamador (controller) e a execução de uma ação específica (caso de uso), promovendo desacoplamento e testabilidade.

---

## Metodologia

A construção deste trabalho seguiu os seguintes passos:

1. **Análise do cenário real do projeto:** o sistema possui funcionalidades de cadastro de usuários e login, utilizadas para adotar ou doar pets.  
2. **Identificação de casos de uso isolados:** ações como registrar usuário e logar foram tratadas como comandos independentes.  
3. **Criação de comandos específicos:** `RegisterCommand` e `LoginCommand`, responsáveis por executar cada operação.  
4. **Padronização de resultados:** implementação de um objeto `Result` para encapsular sucesso ou falha das operações.  
5. **Validação com código funcional dentro do ambiente Rails e PostgreSQL.**

---

## Desenvolvimento

No sistema, o controller de usuários precisava realizar operações como cadastro e login sem acumular lógica de negócio complexa. Para isso, aplicamos o padrão **Command**, encapsulando cada ação em uma classe específica.

### Comando de registro (`register_command.rb`)

```ruby
module Users
  class RegisterCommand
    def initialize(params)
      @params = params
    end

    def call
      user = User.new(params)
      if user.save
        Result.success(user)
      else
        Result.failure(user.errors.full_messages)
      end
    end

    private

    attr_reader :params
  end
end
```

### Comando de login (`login_command.rb`)

```ruby
module Users
  class LoginCommand
    def initialize(email, password)
      @email = email
      @password = password
    end

    def call
      user = User.find_by(email: email, password: password)

      if user
        Result.success(user)
      else
        Result.failure("Email ou senha inválidos")
      end
    end

    private

    attr_reader :email, :password
  end
end
```

### Objeto Resultado (`result.rb`)

```ruby
class Result
  attr_reader :data, :errors

  def initialize(success:, data: nil, errors: nil)
    @success = success
    @data = data
    @errors = errors
  end

  def self.success(data = nil) = new(success: true, data: data)
  def self.failure(errors = nil) = new(success: false, errors: errors)

  def success? = @success
  def failure? = !@success
end
  ```


### Bibliografia

- Refactoring Guru. Command. Disponível em: https://refactoring.guru/pt-br/design-patterns/command.
- GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. Padrões de Projeto: Soluções reutilizáveis de software orientado a objetos. Porto Alegre: Bookman, 2000.
- SERRANO, Milene. Aula - GoFs Comportamentais. Universidade de Brasília, 2025.
# *Factory Method*

## **Introdução**

O **padrão Factory Method**, pertencente ao grupo de padrões criacionais definidos pela **Gang of Four (GoF)**, tem como objetivo **delegar a criação de objetos para subclasses ou classes especializadas**, promovendo o **baixo acoplamento** e a **extensibilidade** do sistema.

Neste contexto, o diagrama de classes representa a aplicação desse padrão em um módulo de gerenciamento de pets. Ele descreve como o **controller** (cliente) delega a criação de objetos concretos de pets (`Dog`, `Cat`, etc.) para uma **fábrica** responsável por instanciar dinamicamente o tipo correto, com base nos parâmetros de entrada.

Esse modelo proporciona uma arquitetura mais flexível, permitindo adicionar novas espécies sem alterar o código do controller, apenas estendendo a fábrica com novas classes concretas. Isso é útil por que animais tomam vacinas diferentes, por exemplo, pensando na expansão do produto é interessante essa divisão pensando em suas características únicas.

---

## **Metodologia**

A modelagem foi desenvolvida com base na implement_ação do **Factory Method** aplicada ao `PetsController` de um sistema Ruby on Rails. O trabalho foi realizado de forma colaborativa pelos integrantes do grupo, utilizando a ferramenta **Draw.io** para a elaboração do diagrama UML.

A metodologia seguiu os seguintes passos:
1. Identificação das classes envolvidas no padrão (Cliente, Fábrica, Produto e Produtos Concretos);
2. Definição dos atributos e métodos relevantes de cada classe;
3. Representação dos relacionamentos (associação e herança);
4. Validação do diagrama em grupo para garantir a coerência conceitual e sintática.
5. Implementação prática no código com interface básica.

A escolha do **Draw.io** se deu por sua conformidade com a notação UML e pela facilidade de colaboração visual.
A escolha do ruby on rails se deu pela facilidade do membros de trabalharem com a tecnologia e possibilidade de aplicação dos GOFs no framework.

---

## **Tabela de Participação na Produção do Artefato**

<center>

| <center>Nome do<br>Integrante | <center>Artefato | <center>Descrição da<br>Contribuição | <center>Análise Crítica | <center>Link Comprobatório |
| :--- | :--- | :--- | :--- | :--- |
| **Erick** | Diagrama de Classes - Factory Method | Modelei a hierarquia de classes (`Pet`, `Dog`, `Cat`) e estabeleci o relacionamento entre o controller e a fábrica. | A principal análise foi garantir o desacoplamento entre o controller e as subclasses concretas. O controller apenas chama a fábrica, sem conhecer as classes concretas, respeitando o princípio da inversão de dependência. | [Modelagem](https://app.diagrams.net/#G1TB4jtd7THebmIcC5f9MldFp98Jx5l9X7#%7B%22pageId%22%3A%22C5RBs43oDa-KdzZeNtuy%22%7D) |
| **Ian e José** | Implementação do Factory em Código | Implementação da factory em código, transformando a modelagem em código de fato. | A análise da modelagem e transformar em prática foi abstrata no início, porém tomando cuidado com o principio da inversão de dependência e pensando que a controller deve chamar um método abstrato conseguimos sem grandes problemas. Apesar do GOF ter sido aplicado, ainda há margem para melhora definitivamente. | [commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/pull/8/commits/3369edf6e331f1950db3e6db90866d71f7534520) |
| **Vinicius** | Extensão do do Factory em Código | Implementação de novos metodos para os pets. | A adição do método movement foi uma boa contribuição, pois reforça o uso do polimorfismo, que é central em padrões como o Factory Method. Ele demonstra corretamente como subclasses (Dog, Cat) podem especializar comportamentos definidos na classe base (Pet). A atualização no controller para logar a nova ação valida que a fábrica está instanciando o objeto correto. | [commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/de10f72578a7db79962c733fc08d92abf1927061) |
| **Mateus** | Extensão do Factory em Código | Implementação do método info nas classes Pet, Dog e Cat. | O método info permite exibir informações básicas do pet, reforçando o uso do polimorfismo e facilitando a visualização dos dados de cada instância. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/b496397af2f0bfc27a424b6a74dcdcde326db9bc) |
| **Davi** | Extensão do Factory em Código | Implementação do método tipo nas classes Pet, Dog e Cat. | O método tipo permite identificar o tipo do pet de forma polimórfica, tornando o sistema mais flexível para consultas e exibições. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/b496397af2f0bfc27a424b6a74dcdcde326db9bc) |

</center>

---

## **Resultados**

**Diagrama de Classes:**

<center>

![Diagrama de Classes - Factory Method](../assets/FactoryMethod/diagrama_factory_method.jpg) <br>
Autores: Erick

</center>

### **Descrição das Classes**

- **PetsController**: Classe cliente que utiliza a fábrica para criar instâncias de pets.  
- **PetFactory**: Classe responsável por decidir qual classe concreta será instanciada com base na espécie informada.  
- **Pet (Abstract Product)**: Classe base que define atributos e comportamentos genéricos de pets.  
- **Dog / Cat (Concrete Products)**: Subclasses concretas que estendem `Pet` e implementam comportamentos específicos (como `sound()`).

### **Código das Classes**
**Pets Controller:**
```ruby
    class PetsController < ApplicationController
    before_action :set_pet, only: %i[ show edit update destroy ]

    # GET /pets or /pets.json
    def index
        @pets = Pet.all
    end

    # GET /pets/1 or /pets/1.json
    def show
        # Adicionando um log para demonstrar o método exclusivo do Concrete Product, se existir
        puts "Pet sound check: #{@pet.sound}" if @pet.respond_to?(:sound)
    end

    # GET /pets/new
    def new
        @pet = Pet.new
    end

    # GET /pets/1/edit
    def edit
    end

    # POST /pets or /pets.json
    def create
        # APLICAÇÃO DO PADRÃO CRIACIONAL (FACTORY METHOD)
        # Ele apenas delega a responsabilidade para a PetFactory.
        @pet = PetFactory.create(pet_params)

        respond_to do |format|
        if @pet.save
            # Lógica de demonstração no console (verifique a saída do 'rails s')
            puts "LOG: Pet criado com sucesso usando a Factory. Tipo: #{@pet.species}"
            puts "LOG: Testando método exclusivo: #{@pet.sound}" if @pet.respond_to?(:sound)

            format.html { redirect_to pet_url(@pet), notice: "Pet cadastrado com sucesso (via Factory)!" }
            format.json { render :show, status: :created, location: @pet }
        else
            format.html { render :new, status: :unprocessable_entity }
            format.json { render json: @pet.errors, status: :unprocessable_entity }
        end
        end
    end

    # PATCH/PUT /pets/1 or /pets/1.json
    def update
        respond_to do |format|
        if @pet.update(pet_params)
            format.html { redirect_to @pet, notice: "Pet was successfully updated.", status: :see_other }
            format.json { render :show, status: :ok, location: @pet }
        else
            format.html { render :edit, status: :unprocessable_entity }
            format.json { render json: @pet.errors, status: :unprocessable_entity }
        end
        end
    end

    # DELETE /pets/1 or /pets/1.json
    def destroy
        @pet.destroy!

        respond_to do |format|
        format.html { redirect_to pets_path, notice: "Pet was successfully destroyed.", status: :see_other }
        format.json { head :no_content }
        end
    end

    private
        # Use callbacks to share common setup or constraints between actions.
        def set_pet
        @pet = Pet.find(params[:id])
        end

        # A Factory precisa do 'species' para funcionar, então ele deve ser permitido aqui.
        def pet_params
        params.require(:pet).permit(:name, :species, :age, :description, :adopted)
        end
    end
```
<center>
  Autores: Ian e José
</center>

**Classe Dog**
``` ruby
    class Dog < Pet
  # Método exclusivo do Dog para demonstração do objeto correto e do GOF factory
  def sound
    "Au Au! (Sou um Dog, minha Factory me deu este super poder)"
  end

end
```
**Classe Cat**
```ruby
    # Representa um tipo de Pet criado pela Factory
class Cat < Pet
  # Método exclusivo do Cat para demonstração do objeto correto e do GOF factory
  def sound
    "Miau! (Sou um Cat, minha Factory me criou com este som)"
  end  

end
```
<center>
  Autores: Ian e José
</center>

**Classe Pet**
```ruby
class Pet < ApplicationRecord
  # Validação simples para garantir que a Factory está funcionando
  validates :name, presence: true
  validates :species, presence: true

  # Método padrão para o caso de não ser um tipo especial (Dog ou Cat)
  def sound
    "..."
  end
end
```
<center>
  Autores: Ian e José
</center>

---

**Contribuição Vinicius**

*Classe Dog*
```ruby
def movement
    "Correndo e abanando o rabo! (Movimento de Dog)"
  end
   def tipo
     "Dog"
   end
```
*Classe Cat*
```ruby
def movement
    "Andando silenciosamente... (Movimento de Cat)"
  end
   def tipo
     "Cat"
   end
```
*Classe Pet*
```ruby
 def movement
    "(Se movendo de forma genérica)"
  end
   def tipo
     "Genérico"
   end
```
*pets_controller*
```ruby
  def show
      # Adicionando um log para demonstrar o método exclusivo do Concrete Product, se existir
      puts "Pet sound check: #{@pet.sound}" if @pet.respond_to?(:sound)
      # Logando o movimento no 'show' também
      puts "Pet movement check: #{@pet.movement}" if @pet.respond_to?(:movement)
  end
  def create
      # APLICAÇÃO DO PADRÃO CRIACIONAL (FACTORY METHOD)
      # Ele apenas delega a responsabilidade para a PetFactory.
      @pet = PetFactory.create(pet_params)

      respond_to do |format|
      if @pet.save
          # Lógica de demonstração no console (verifique a saída do 'rails s')
          puts "LOG: Pet criado com sucesso usando a Factory. Tipo: #{@pet.species}"
          puts "LOG: Testando método exclusivo (sound): #{@pet.sound}" if @pet.respond_to?(:sound)
          # Logando o novo método de movimento
          puts "LOG: Testando método exclusivo (movement): #{@pet.movement}" if @pet.respond_to?(:movement)

          format.html { redirect_to pet_url(@pet), notice: "Pet cadastrado com sucesso (via Factory)!" }
          format.json { render :show, status: :created, location: @pet }
      else
          format.html { render :new, status: :unprocessable_entity }
          format.json { render json: @pet.errors, status: :unprocessable_entity }
      end
      end
  end
```
<center>
  Autores: Vinicius
</center>

## **Gravação da Produção do Artefato**

<center>

* **Gravação Erick:** [Link para a Gravação](https://drive.google.com/drive/my-drive?hl=pt-br&q=after:2025-10-23%20parent:0AN6P6VEJEJLcUk9PVA)

**Gravação Ian e José:**
<iframe src="https://unbbr.sharepoint.com/sites/ArqDSW-G4/_layouts/15/embed.aspx?UniqueId=70e076a5-8e34-44e6-b019-65045d02f876&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=StreamWebApp&referrerScenario=EmbedDialog.Create" width="1280" height="720" frameborder="0" scrolling="no" allowfullscreen title="Revisão GoFs - Ian e José-20251023_230438-Gravação de Reunião.mp4"></iframe>


</center>

---

## **Referências Bibliográficas**

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley, 1994.  
> RAFAEL. Introdução aos padrões criacionais: Abstract Factory, Factory Method, Prototype e Singleton. **DevMedia**, Rio de Janeiro, 2011. Disponível em: <https://www.devmedia.com.br/introducao-aos-padroes-criacionais-abstract-factory-factory-method-prototype-e-singleton/21249>. Acesso em: 20 out. 2025.

---

## **Histórico de versões**

| Versão | Data       | Descrição | Autores | Revisor |
| :--- | :--- | :--- | :--- | :--- |
| 1.0 | 22/10/2025 | Criação inicial do documento e do diagrama de classes do Factory Method | Erick  | Ian |
| 1.1 | 23/10/2025 | Adição da parte prática inicial do factory | Ian e José  | Erick |
| 1.2 | 24/10/2025 | Adição do código e das comprovações | Ian e José | Erick |
| 1.3 | 24/10/2025 | Adição de novos métodos | Vinicius |  |
| 1.4 | 24/10/2025 | Adição do método que traz informações sobre as classes Pet, Dog e Cat | Mateus |  |
| 1.5 | 24/10/2025 | Adição do método tipo nas classes Pet, Dog e Cat | Davi |  |
| 1.6 | 24/10/2025 | Adição do método vaccine_info nas classes de Pet | Daniel e Caio|  |
| 1.7 | 24/10/2025 | Correção de bug: Removido método destroy privado duplicado no PetsController. | Daniel e Caio|  |


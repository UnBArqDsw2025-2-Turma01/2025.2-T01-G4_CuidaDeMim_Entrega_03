# 3.3.1 Strategy Pattern

## **Introdução**

O **padrão Strategy**, pertencente ao grupo de padrões comportamentais definidos pela **Gang of Four (GoF)**, tem como objetivo **definir uma família de algoritmos, encapsular cada um deles e torná-los intercambiáveis**. Isso permite que o algoritmo varie independentemente dos clientes que o utilizam, promovendo **baixo acoplamento** e a **extensibilidade** do sistema.

Neste contexto, o diagrama de classes representa a aplicação desse padrão em um módulo de geração de relatórios. Ele descreve como o **controller** (cliente) delega a execução do relatório a um **Contexto** (`ReportContext`), que por sua vez utiliza a **Estratégia** (`StrategyInterface`) correta para realizar a operação.

Esse modelo proporciona uma arquitetura flexível, permitindo adicionar novos tipos de relatórios (ex: `FinancialReportStrategy`) sem alterar o código do controller, apenas criando uma nova classe de estratégia concreta.

---

## **Metodologia**

A modelagem foi desenvolvida com base na implementação do padrão comportamental **Strategy** aplicado ao sistema de gerenciamento de usuários para adoção e doação de pets, desenvolvido em **Ruby on Rails** com **PostgreSQL**.

O trabalho foi realizado de forma colaborativa pelos integrantes do grupo, utilizando a ferramenta **Draw.io** para a elaboração dos diagramas UML e o framework **Rails** para a implementação prática.

A modelagem do **Strategy Pattern** foi aplicada ao módulo de relatórios (`Admin::ReportsController`) e seguiu os seguintes passos:

1. Identificação das classes envolvidas no padrão (Cliente, Contexto, Estratégia e Estratégias Concretas);  
2. Definição dos atributos e métodos relevantes de cada classe;  
3. Representação dos relacionamentos (associação, implementação e dependência);  
4. Validação do diagrama em grupo para garantir a coerência conceitual e sintática;  
5. Implementação prática no código com interface básica.

A escolha do **Draw.io** se deu por sua conformidade com a notação UML e pela facilidade de colaboração visual.  
A escolha do **Ruby on Rails** se deu pela familiaridade dos membros com a tecnologia e pela facilidade de aplicar os padrões GoF no framework.

---

## **Tabela de Participação na Produção do Artefato**

<center>

| <center>Nome do<br>Integrante | <center>Artefato | <center>Descrição da<br>Contribuição | <center>Análise Crítica | <center>Link Comprobatório |
| :--- | :--- | :--- | :--- | :--- |
| **[Daniel e Vinicius]** | Diagrama de Classes - Strategy Pattern | Modelei a hierarquia de classes (`ReportContext`, `StrategyInterface`, `UserReportStrategy`, `AdoptionReportStrategy`) e estabeleci os relacionamentos entre o controller, o contexto e as estratégias. | A análise principal foi garantir que o controller permaneça desacoplado das implementações concretas dos relatórios. O controller apenas configura o `ReportContext`, que por sua vez delega a execução, permitindo adicionar novos relatórios sem alterar o controller. | [Modelagem](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZEVJSKygBBKoRGN6KlCmDgBcU9NbAlyZaXct1QAl4usFA?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=cnLNzO) |
| **[Vinicius]** | Implementação do Strategy em Código | Implementação do `ReportContext` e das classes de estratégia (`UserReportStrategy`, `AdoptionReportStrategy`) em Ruby on Rails, seguindo a modelagem. | A implementação do `ReportContext` com um *Hash* de `STRATEGIES` permitiu uma seleção dinâmica e limpa do algoritmo. A `StrategyInterface` garantiu um contrato unificado, e a lógica de template (em `handle_report`) centralizou a montagem do hash de resposta. | [código](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EQxQOfYzvb1PkV6_tcoi7QIB8uVoIhs27JhSiecKygwIJQ?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=Mn8O4j) |
| **Ian** | Extensão do Strategy Pattern | 1. Implementação da nova Estratégia Concreta: `PartnershipReportStrategy`. 2. Integração da nova Estratégia no `ReportContext` (via `STRATEGIES` Hash). | A extensão do código confirmou a flexibilidade e o baixo acoplamento do padrão Strategy, pois a adição foi feita sem modificar a lógica central de execução. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/7ddd2cac0d09095306761d972d2552c793aa7515) |
| **José** | Extensão do Strategy Pattern (Mock Data) | Implementação do método `fetch_partnership_data` no `mock_data.rb`, fornecendo dados para a nova estratégia. | Garantiu a funcionalidade imediata da nova estratégia em ambiente de desenvolvimento, provendo a base de dados simulada para o relatório de parcerias. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/7ddd2cac0d09095306761d972d2552c793aa7515) |
| **Erick Santos** | Serviço Auxiliar de Exclusão | Implementação do serviço `DeletePet` seguindo princípios de encapsulamento e separação de responsabilidades, com tratamento robusto de erros e logging detalhado. | A criação deste serviço demonstra a aplicação de boas práticas de arquitetura, encapsulando a lógica de exclusão em uma classe dedicada, facilitando reutilização e manutenção do código. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/70b249fb5ff31fbe169bad965e717057f0446628) |
| **[Mateus]** | Extensão do Strategy Pattern (Método available_strategies) | Implementação do método público `available_strategies` em `ReportContext`, permitindo consultar dinamicamente os tipos de relatório disponíveis no sistema. | Facilitou a consulta dinâmica das estratégias implementadas, tornando o sistema mais flexível para integrações futuras e para uso em interfaces dinâmicas. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/b496397af2f0bfc27a424b6a74dcdcde326db9bc) |
| **[Davi]** | Extensão do Strategy Pattern (Revisão e Correção do Contexto) | Revisão e correção do construtor de `ReportContext`, restaurando o uso do hash STRATEGIES e removendo parâmetros desnecessários, garantindo compatibilidade e clareza na arquitetura. | Garantiu que o contexto do padrão Strategy permanecesse simples, seguro e alinhado com as boas práticas de encapsulamento e desacoplamento. | [Commit](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G4_CuidaDeMim_Entrega_03/commit/b496397af2f0bfc27a424b6a74dcdcde326db9bc) |


</center>

---

## **Resultados**

**Diagrama de Classes:**

<center>

![Diagrama de Classes - Strategy Method](../assets/StrategyMethod/diagrama_strategy.PNG)

</center>

### **Descrição das Classes**

- **AdminReportsController (Client)**: Classe cliente que decide qual estratégia será utilizada. Ela instancia o `ReportContext` com o `report_type` desejado.
- **ReportContext (Context)**: Mantém uma referência à `StrategyInterface` e se comunica com ela. É responsável por selecionar a estratégia concreta (via `STRATEGIES`) e invocar sua execução através do método `execute_report()`.
- **Reports::StrategyInterface (Strategy)**: Interface (ou classe base) que define o método comum (`handle_report()`) para todos os algoritmos (estratégias).
- **UserReportStrategy / AdoptionReportStrategy (Concrete Products)**: Subclasses concretas que implementam os métodos da interface, cada uma fornecendo uma versão específica do algoritmo de geração de relatório.

---

## **Gravação da Produção do Artefato**

<center>

* **Gravação Diagrama (Vinicius e Daniel)** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZEVJSKygBBKoRGN6KlCmDgBcU9NbAlyZaXct1QAl4usFA?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=cnLNzO)

</center>

---

### **Código**

### strategy_interface.rb
```ruby
class Reports::StrategyInterface
  
  def handle_report

    data = fetch_data
    
    rows = format_rows(data)
    
    headers = build_headers
    
    title = build_title
    
    return { title: title, headers: headers, rows: rows }
  end

  protected

  def fetch_data
    raise NotImplementedError, "#{self.class.name} não implementou o método 'fetch_data'"
  end

  def format_rows(data)
    raise NotImplementedError, "#{self.class.name} não implementou o método 'format_rows'"
  end

  def build_headers
    raise NotImplementedError, "#{self.class.name} não implementou o método 'build_headers'"
  end

  def build_title
    raise NotImplementedError, "#{self.class.name} não implementou o método 'build_title'"
  end
end
```

### user_report_strategy.rb
```ruby
require_relative 'strategy_interface'
require_relative 'mock_data'
class Reports::UserReportStrategy < Reports::StrategyInterface

  protected

  def fetch_data
    Reports::MockData.fetch_user_data
  end

  def format_rows(data)
    data.map do |user| 
      [user[:id], user[:nome], user[:email], user[:tipo], user[:data_cadastro]] 
    end
  end

  def build_headers
    ["ID", "Nome", "Email", "Tipo", "Data de Cadastro"]
  end

  def build_title
    "Relatório de Usuários Cadastrados"
  end
end
```

### adoption_report_strategy.rb
```ruby
require_relative 'strategy_interface'
require_relative 'mock_data'

# Herda da classe Reports::StrategyInterface
class Reports::AdoptionReportStrategy < Reports::StrategyInterface

  protected

  def fetch_data
    Reports::MockData.fetch_adoption_data
  end

  def format_rows(data)
    data.map do |adocao| 
      [adocao[:id], adocao[:pet], adocao[:ong], adocao[:adotante], adocao[:data]]
    end
  end

  def build_headers
    ["ID Adoção", "Nome do Pet", "ONG/Parceiro", "Adotante", "Data Aprovação"]
  end

  def build_title
    "Relatório de Adoções Aprovadas"
  end
end
```
<center>
  Autores: Daniel e Vinícius
</center>

### partnership_report_strategy.rb
``` ruby
require_relative 'strategy_interface'
require_relative 'mock_data'

class Reports::PartnershipReportStrategy < Reports::StrategyInterface

  protected

  def fetch_data
    Reports::MockData.fetch_partnership_data
  end

  def format_rows(data)
    data.map do |parceria| 
      [parceria[:id], parceria[:nome], parceria[:contato], parceria[:status], parceria[:pets_cadastrados], parceria[:adocoes_efetivadas]] 
    end
  end

  def build_headers
    ["ID Parceria", "Nome da Instituição", "Contato", "Status", "Pets Cadastrados", "Adoções Efetivadas"]
  end

  def build_title
    "Relatório de Desempenho de Parcerias"
  end
end

```
<center>
  Autores: Ian e José
</center>

### report_context.rb
```ruby
class ReportContext
  STRATEGIES = {
    'user_report' => Reports::UserReportStrategy.new,
    'adoption_report' => Reports::AdoptionReportStrategy.new,
    #A Extensão foi feita aqui
    'partnership_report' => Reports::PartnershipReportStrategy.new
  }.freeze
  attr_reader :strategy

  def initialize(report_type)
    @strategy = STRATEGIES[report_type]
  end
  def execute_report
    unless @strategy
      raise "Tipo de Relatório Inválido: Não há estratégia definida."
    end
    @strategy.handle_report
  end
end
```
<center>
  Autores: Daniel e Vinícius
</center>

### reports_controller.rb
```ruby
require 'csv'
class Admin::ReportsController < ApplicationController
  
  def index
  end
  def create
    report_type = params[:report_type]
    context = ReportContext.new(report_type)
    @report_data = context.execute_report
    respond_to do |format|
      format.html do
        render :show
      end
      format.csv do
        csv_string = CSV.generate(headers: true) do |csv|
          csv << @report_data[:headers]
          @report_data[:rows].each do |row|
            csv << row
          end
        end
        filename = "relatorio_#{report_type}_#{Time.now.strftime('%Y%m%d')}.csv"
        send_data csv_string, filename: filename
      end
    end
    rescue => e
    redirect_to admin_reports_path, alert: "Erro: #{e.message}"
  end
end
```
<center>
  Autores: Daniel e Vinícius
</center>

### delete_pet.rb
```ruby
# frozen_string_literal: true

# Serviço para exclusão de pets do sistema
# Responsabilidade: Realizar a exclusão de um pet com tratamento de erros
class DeletePet
  # Realiza a exclusão de um pet do sistema
  # @param pet [Pet] O objeto pet a ser excluído
  # @return [Hash] Resultado da exclusão com status e mensagem
  def self.delete(pet)
    if pet.destroy
      Rails.logger.info("Pet '#{pet.name}' excluído com sucesso.")
      {
        success: true,
        message: "Pet '#{pet.name}' excluído com sucesso!",
        pet: pet
      }
    else
      Rails.logger.error("Erro ao excluir pet: #{pet.errors.full_messages.join(', ')}")
      {
        success: false,
        message: "Erro ao excluir pet: #{pet.errors.full_messages.join(', ')}",
        pet: pet
      }
    end
  rescue StandardError => e
    Rails.logger.error("Erro inesperado ao excluir pet: #{e.message}")
    {
      success: false,
      message: "Erro inesperado ao excluir pet: #{e.message}",
      pet: pet
    }
  end
end
```
<center>
  Autor: Erick Santos
</center>

---

## Demonstração do Código sendo Executado

- **Execução do Código** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EQxQOfYzvb1PkV6_tcoi7QIB8uVoIhs27JhSiecKygwIJQ?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=Mn8O4j)

- **Site Rodando** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZ_mqeuQnNtCrIodRxjNAxwB22-gXHxnpx7f3fNeHixUqw?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=baG2PO)

---

## **Referências Bibliográficas**

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley, 1994.

> REFACTORING GURU. Strategy design pattern. Disponível em: <https://refactoring.guru/design-patterns/strategy>. Acesso em: 23 de outubro 2025.

---

## **Histórico de versões**

| Versão | Data       | Descrição | Autores | Revisor |
| :--- | :--- | :--- | :--- | :--- |
| 1.0 | 22/10/2025 | Criação inicial do documento e do diagrama de classes do Strategy Method | Daniel e Vinicius  |  |
| 1.1 | 23/10/2025 | Adição da parte prática inicial do Strategy | Vinicius  | Daniel |
| 1.2 | 24/10/2025 | Adição da nova Estratégia (`PartnershipReportStrategy`) e do método de Mock Data correspondente comprovando a extensibilidade do padrão.| Ian e José | |
| 1.3 | 24/10/2025 | Adição do serviço `DeletePet` para exclusão de pets com tratamento robusto de erros e logging | Erick Santos | |
| 1.4 | 24/10/2025 | Implementação do método `available_strategies` em `ReportContext` para consulta dinâmica dos tipos de relatório disponíveis | Mateus | |
| 1.5 | 24/10/2025 | Revisão e correção do construtor de `ReportContext`, restaurando o uso do hash STRATEGIES e removendo parâmetros desnecessários | Davi | |
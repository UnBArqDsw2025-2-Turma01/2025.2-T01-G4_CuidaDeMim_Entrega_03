# 3.3.2 Command Pattern

## **Introdução**

O padrão **Command**, pertencente ao grupo de padrões comportamentais definidos pela **Gang of Four (GoF)**, tem como objetivo encapsular uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações, enfileirar ou registrar ações e oferecer suporte a operações desfazíveis. Ele atua como um intermediário entre o chamador (controller) e a execução de uma ação específica (caso de uso), promovendo desacoplamento e testabilidade.

Este documento apresenta a aplicação prática do padrão Command em um sistema de gerenciamento de usuários para adoção e doação de pets, construído com Ruby on Rails e PostgreSQL.

---

## **Metodologia**

A modelagem foi desenvolvida com base na implementação do padrão comportamental **Command** aplicado ao sistema de gerenciamento de usuários para adoção e doação de pets, desenvolvido em **Ruby on Rails** com **PostgreSQL**.

O trabalho foi realizado de forma colaborativa pelos integrantes do grupo, utilizando a ferramenta **Draw.io** para a elaboração dos diagramas UML e o framework **Rails** para a implementação prática.

A construção deste trabalho seguiu os seguintes passos:

1. **Análise do cenário real do projeto:** o sistema possui funcionalidades de cadastro de usuários e login, utilizadas para adotar ou doar pets.  
2. **Identificação de casos de uso isolados:** ações como registrar usuário e logar foram tratadas como comandos independentes.  
3. **Criação de comandos específicos:** `RegisterCommand` e `LoginCommand`, responsáveis por executar cada operação.  
4. **Padronização de resultados:** implementação de um objeto `Result` para encapsular sucesso ou falha das operações.  
5. **Validação com código funcional dentro do ambiente Rails e PostgreSQL.**

Essa abordagem reforça o **baixo acoplamento** e a **testabilidade** do sistema, permitindo que cada operação seja encapsulada e executada de forma independente, conforme os princípios do **Command Pattern**.

---

## **Tabela de Participação na Produção do Artefato**

<center>

| <center>Nome do<br>Integrante | <center>Artefato | <center>Descrição da<br>Contribuição | <center>Análise Crítica | <center>Link Comprobatório |
| :--- | :--- | :--- | :--- | :--- |
| **[Caio Antonio]** | Diagrama de Classes e Implementação - Command Pattern | Criação do diagrama de classes e implementação do sistema de autenticação utilizando o Command Pattern | A implementação do padrão Command permitiu encapsular as operações de registro e login como objetos independentes, facilitando a testabilidade e manutenção do código. O objeto Result padronizou o retorno das operações. | [Gravação Diagrama](https://unbbr-my.sharepoint.com/personal/221031130_aluno_unb_br/_layouts/15/stream.aspx?id=/personal/221031130_aluno_unb_br/Documents/Grava%C3%A7%C3%B5es/Reuni%C3%A3o%20com%20Caio%20Antonio%20Araujo%20Garcia%20De%20Almeida-20251024_111044-Grava%C3%A7%C3%A3o%20de%20Reuni%C3%A3o.mp4) |

</center>

---

## **Resultados**

**Diagrama de Classes:**

<center>

![Diagrama de Classes - Command Method](../assets/StrategyMethod/diagrama_command.PNG)

</center>

### **Descrição das Classes**

- **Client**: Classe cliente que orquestra as operações de registro e login de usuários. Instancia e executa os comandos apropriados conforme a ação solicitada.

- **RegisterCommand**: Comando responsável por encapsular a lógica de registro de novos usuários. Recebe os parâmetros do usuário, cria uma instância de `User`, tenta salvá-la e retorna um objeto `Result` indicando sucesso ou falha.

- **LoginCommand**: Comando responsável por encapsular a lógica de autenticação. Recebe email e senha, busca o usuário correspondente no banco de dados e retorna um objeto `Result` com o usuário encontrado ou mensagem de erro.

- **Result**: Objeto de valor que encapsula o resultado de uma operação. Pode representar sucesso (com dados) ou falha (com erros), fornecendo métodos `success?()` e `failure?()` para verificação do estado.

- **User**: Modelo de domínio (ActiveRecord) que representa um usuário no sistema. Fornece métodos para persistência (`save()`) e busca (`find_by()`), além de validações e erros.

---

## **Gravação da Produção do Artefato**

<center>

* **Gravação Diagrama Command (Caio)** [Link para a Gravação](https://unbbr-my.sharepoint.com/personal/221031130_aluno_unb_br/_layouts/15/stream.aspx?id=/personal/221031130_aluno_unb_br/Documents/Grava%C3%A7%C3%B5es/Reuni%C3%A3o%20com%20Caio%20Antonio%20Araujo%20Garcia%20De%20Almeida-20251024_111044-Grava%C3%A7%C3%A3o%20de%20Reuni%C3%A3o.mp4)

</center>

---

### **Código**

### Comando de registro (`register_command.rb`)

```ruby
module Users
  class RegisterCommand
    def initialize(params)
      @params = params
    end

    def call
      user = User.new(params)
      if user.save
        Result.success(user)
      else
        Result.failure(user.errors.full_messages)
      end
    end

    private

    attr_reader :params
  end
end
```

### Comando de login (`login_command.rb`)

```ruby
module Users
  class LoginCommand
    def initialize(email, password)
      @email = email
      @password = password
    end

    def call
      user = User.find_by(email: email, password: password)

      if user
        Result.success(user)
      else
        Result.failure("Email ou senha inválidos")
      end
    end

    private

    attr_reader :email, :password
  end
end
```

### Objeto Resultado (`result.rb`)

```ruby
class Result
  attr_reader :data, :errors

  def initialize(success:, data: nil, errors: nil)
    @success = success
    @data = data
    @errors = errors
  end

  def self.success(data = nil) = new(success: true, data: data)
  def self.failure(errors = nil) = new(success: false, errors: errors)

  def success? = @success
  def failure? = !@success
end
```

## Demonstração do Código sendo Executado

- **Execução do sistema de autenticação** [Link para a Gravação](https://unbbr-my.sharepoint.com/personal/221031130_aluno_unb_br/_layouts/15/stream.aspx?id=/personal/221031130_aluno_unb_br/Documents/Grava%C3%A7%C3%B5es/Reuni%C3%A3o%20com%20Caio%20Antonio%20Araujo%20Garcia%20De%20Almeida-20251024_112818-Grava%C3%A7%C3%A3o%20de%20Reuni%C3%A3o.mp4)

---

## **Referências Bibliográficas**

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley, 1994.

> REFACTORING GURU. Command design pattern. Disponível em: <https://refactoring.guru/design-patterns/command>. Acesso em: 24 de outubro 2025.

---

## **Histórico de versões**

| Versão | Data       | Descrição | Autores | Revisor |
| :--- | :--- | :--- | :--- | :--- |
| 1.2 | 24/10/2025 | Criação do diagrama de classes e implementação do sistema de autenticação utilizando o Command Pattern | Caio Antonio |  |
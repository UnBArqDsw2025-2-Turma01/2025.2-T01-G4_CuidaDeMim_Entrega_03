# *Strategy Pattern*

## **Introdução**

Este documento apresenta os padrões de projeto comportamentais **Strategy** e **Command**, conforme descritos pelo Gang of Four (GoF), e sua aplicação prática em um sistema de gerenciamento de usuários para adoção e doação de pets, construído com Ruby on Rails e PostgreSQL.

O **padrão Strategy**, pertencente ao grupo de padrões comportamentais definidos pela **Gang of Four (GoF)**, tem como objetivo **definir uma família de algoritmos, encapsular cada um deles e torná-los intercambiáveis**. Isso permite que o algoritmo varie independentemente dos clientes que o utilizam, promovendo **baixo acoplamento** e a **extensibilidade** do sistema.


Neste contexto, o diagrama de classes representa a aplicação desse padrão em um módulo de geração de relatórios. Ele descreve como o **controller** (cliente) delega a execução do relatório a um **Contexto** (`ReportContext`), que por sua vez utiliza a **Estratégia** (`StrategyInterface`) correta para realizar a operação.

Esse modelo proporciona uma arquitetura flexível, permitindo adicionar novos tipos de relatórios (ex: `FinancialReportStrategy`) sem alterar o código do controller, apenas criando uma nova classe de estratégia concreta.

O padrão **Command** tem como objetivo encapsular uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações, enfileirar ou registrar ações e oferecer suporte a operações desfazíveis. Ele atua como um intermediário entre o chamador (controller) e a execução de uma ação específica (caso de uso), promovendo desacoplamento e testabilidade.

---

## **Metodologia**

A modelagem foi desenvolvida com base na implementação dos padrões comportamentais **Strategy** e **Command** aplicados ao sistema de gerenciamento de usuários para adoção e doação de pets, desenvolvido em **Ruby on Rails** com **PostgreSQL**.  
O trabalho foi realizado de forma colaborativa pelos integrantes do grupo, utilizando a ferramenta **Draw.io** para a elaboração dos diagramas UML e o framework **Rails** para a implementação prática.

## Metodologia do Strategy Pattern

A modelagem do **Strategy Pattern** foi aplicada ao módulo de relatórios (`Admin::ReportsController`) e seguiu os seguintes passos:

1. Identificação das classes envolvidas no padrão (Cliente, Contexto, Estratégia e Estratégias Concretas);  
2. Definição dos atributos e métodos relevantes de cada classe;  
3. Representação dos relacionamentos (associação, implementação e dependência);  
4. Validação do diagrama em grupo para garantir a coerência conceitual e sintática;  
5. Implementação prática no código com interface básica.

A escolha do **Draw.io** se deu por sua conformidade com a notação UML e pela facilidade de colaboração visual.  
A escolha do **Ruby on Rails** se deu pela familiaridade dos membros com a tecnologia e pela facilidade de aplicar os padrões GoF no framework.

## Metodologia do Command Pattern

A construção deste trabalho seguiu os seguintes passos:

1. **Análise do cenário real do projeto:** o sistema possui funcionalidades de cadastro de usuários e login, utilizadas para adotar ou doar pets.  
2. **Identificação de casos de uso isolados:** ações como registrar usuário e logar foram tratadas como comandos independentes.  
3. **Criação de comandos específicos:** `RegisterCommand` e `LoginCommand`, responsáveis por executar cada operação.  
4. **Padronização de resultados:** implementação de um objeto `Result` para encapsular sucesso ou falha das operações.  
5. **Validação com código funcional dentro do ambiente Rails e PostgreSQL.**

Essa abordagem reforça o **baixo acoplamento** e a **testabilidade** do sistema, permitindo que cada operação seja encapsulada e executada de forma independente, conforme os princípios do **Command Pattern**.

---

## **Tabela de Participação na Produção do Artefato**

<center>

| <center>Nome do<br>Integrante | <center>Artefato | <center>Descrição da<br>Contribuição | <center>Análise Crítica | <center>Link Comprobatório |
| :--- | :--- | :--- | :--- | :--- |
| **[Daniel e Vinicius]** | Diagrama de Classes - Strategy Pattern | Modelei a hierarquia de classes (`ReportContext`, `StrategyInterface`, `UserReportStrategy`, `AdoptionReportStrategy`) e estabeleci os relacionamentos entre o controller, o contexto e as estratégias. | A análise principal foi garantir que o controller permaneça desacoplado das implementações concretas dos relatórios. O controller apenas configura o `ReportContext`, que por sua vez delega a execução, permitindo adicionar novos relatórios sem alterar o controller. | [Modelagem]<br>(https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZEVJSKygBBKoRGN6KlCmDgBcU9NbAlyZaXct1QAl4usFA?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=cnLNzO) |
| **[Vinicius]** | Implementação do Strategy em Código | Implementação do `ReportContext` e das classes de estratégia (`UserReportStrategy`, `AdoptionReportStrategy`) em Ruby on Rails, seguindo a modelagem. | A implementação do `ReportContext` com um *Hash* de `STRATEGIES` permitiu uma seleção dinâmica e limpa do algoritmo. A `StrategyInterface` garantiu um contrato unificado, e a lógica de template (em `handle_report`) centralizou a montagem do hash de resposta. | [código]<br>(https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EQxQOfYzvb1PkV6_tcoi7QIB8uVoIhs27JhSiecKygwIJQ?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=Mn8O4j) |


</center>

---

## **Resultados**

**Diagrama de Classes:**

<center>

![Diagrama de Classes - Strategy Method](../assets/StrategyMethod/diagrama_strategy.PNG)
![Diagrama de Classes - Command Method](../assets/StrategyMethod/diagrama_command.PNG)

</center>

### **Descrição das Classes Strategy**

- **AdminReportsController (Client)**: Classe cliente que decide qual estratégia será utilizada. Ela instancia o `ReportContext` com o `report_type` desejado.
- **ReportContext (Context)**: Mantém uma referência à `StrategyInterface` e se comunica com ela. É responsável por selecionar a estratégia concreta (via `STRATEGIES`) e invocar sua execução através do método `execute_report()`.
- **Reports::StrategyInterface (Strategy)**: Interface (ou classe base) que define o método comum (`handle_report()`) para todos os algoritmos (estratégias).
- **UserReportStrategy / AdoptionReportStrategy (Concrete Products)**: Subclasses concretas que implementam os métodos da interface, cada uma fornecendo uma versão específica do algoritmo de geração de relatório.

### **Descrição das Classes Command**

- **Client**: Classe cliente que orquestra as operações de registro e login de usuários. Instancia e executa os comandos apropriados conforme a ação solicitada.

- **RegisterCommand**: Comando responsável por encapsular a lógica de registro de novos usuários. Recebe os parâmetros do usuário, cria uma instância de `User`, tenta salvá-la e retorna um objeto `Result` indicando sucesso ou falha.

- **LoginCommand**: Comando responsável por encapsular a lógica de autenticação. Recebe email e senha, busca o usuário correspondente no banco de dados e retorna um objeto `Result` com o usuário encontrado ou mensagem de erro.

- **Result**: Objeto de valor que encapsula o resultado de uma operação. Pode representar sucesso (com dados) ou falha (com erros), fornecendo métodos `success?()` e `failure?()` para verificação do estado.

- **User**: Modelo de domínio (ActiveRecord) que representa um usuário no sistema. Fornece métodos para persistência (`save()`) e busca (`find_by()`), além de validações e erros.

---

## **Gravação da Produção do Artefato**

<center>

* **Gravação Diagrama (Vinicius e Daniel)** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZEVJSKygBBKoRGN6KlCmDgBcU9NbAlyZaXct1QAl4usFA?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=cnLNzO)

* **Gravação Diagrama Command (Caio)** [Link para a Gravação](https://unbbr-my.sharepoint.com/personal/221031130_aluno_unb_br/_layouts/15/stream.aspx?id=/personal/221031130_aluno_unb_br/Documents/Grava%C3%A7%C3%B5es/Reuni%C3%A3o%20com%20Caio%20Antonio%20Araujo%20Garcia%20De%20Almeida-20251024_111044-Grava%C3%A7%C3%A3o%20de%20Reuni%C3%A3o.mp4)


</center>

---

### **Código**


### strategy_interface.rb
```
class Reports::StrategyInterface
  
  def handle_report

    data = fetch_data
    
    rows = format_rows(data)
    
    headers = build_headers
    
    title = build_title
    
    return { title: title, headers: headers, rows: rows }
  end

  protected

  def fetch_data
    raise NotImplementedError, "#{self.class.name} não implementou o método 'fetch_data'"
  end

  def format_rows(data)
    raise NotImplementedError, "#{self.class.name} não implementou o método 'format_rows'"
  end

  def build_headers
    raise NotImplementedError, "#{self.class.name} não implementou o método 'build_headers'"
  end

  def build_title
    raise NotImplementedError, "#{self.class.name} não implementou o método 'build_title'"
  end
end
```
### user_report_strategy.rb
```
require_relative 'strategy_interface'
require_relative 'mock_data'
class Reports::UserReportStrategy < Reports::StrategyInterface

  protected

  def fetch_data
    Reports::MockData.fetch_user_data
  end

  def format_rows(data)
    data.map do |user| 
      [user[:id], user[:nome], user[:email], user[:tipo], user[:data_cadastro]] 
    end
  end

  def build_headers
    ["ID", "Nome", "Email", "Tipo", "Data de Cadastro"]
  end

  def build_title
    "Relatório de Usuários Cadastrados"
  end
end
```
### adoption_report_strategy.rb
```
# Carrega a "Classe Base" (agora chamada strategy_interface) e os dados
require_relative 'strategy_interface'
require_relative 'mock_data'

# Herda da classe Reports::StrategyInterface
class Reports::AdoptionReportStrategy < Reports::StrategyInterface

  protected

  def fetch_data
    Reports::MockData.fetch_adoption_data
  end

  def format_rows(data)
    data.map do |adocao| 
      [adocao[:id], adocao[:pet], adocao[:ong], adocao[:adotante], adocao[:data]]
    end
  end

  def build_headers
    ["ID Adoção", "Nome do Pet", "ONG/Parceiro", "Adotante", "Data Aprovação"]
  end

  def build_title
    "Relatório de Adoções Aprovadas"
  end
end
```
### report_context.rb
```
class ReportContext
  STRATEGIES = {
    'user_report' => Reports::UserReportStrategy.new,
    'adoption_report' => Reports::AdoptionReportStrategy.new
  }.freeze
  attr_reader :strategy

  def initialize(report_type)
    @strategy = STRATEGIES[report_type]
  end
  def execute_report
    unless @strategy
      raise "Tipo de Relatório Inválido: Não há estratégia definida."
    end
    @strategy.handle_report
  end
end
```

### reports_controller.rb
```
require 'csv'
class Admin::ReportsController < ApplicationController
  
  def index
  end
  def create
    report_type = params[:report_type]
    context = ReportContext.new(report_type)
    @report_data = context.execute_report
    respond_to do |format|
      format.html do
        render :show
      end
      format.csv do
        csv_string = CSV.generate(headers: true) do |csv|
          csv << @report_data[:headers]
          @report_data[:rows].each do |row|
            csv << row
          end
        end
        filename = "relatorio_#{report_type}_#{Time.now.strftime('%Y%m%d')}.csv"
        send_data csv_string, filename: filename
      end
    end
    rescue => e
    redirect_to admin_reports_path, alert: "Erro: #{e.message}"
  end
end
```

### Comando de registro (`register_command.rb`)

```ruby
module Users
  class RegisterCommand
    def initialize(params)
      @params = params
    end

    def call
      user = User.new(params)
      if user.save
        Result.success(user)
      else
        Result.failure(user.errors.full_messages)
      end
    end

    private

    attr_reader :params
  end
end
```

### Comando de login (`login_command.rb`)

```ruby
module Users
  class LoginCommand
    def initialize(email, password)
      @email = email
      @password = password
    end

    def call
      user = User.find_by(email: email, password: password)

      if user
        Result.success(user)
      else
        Result.failure("Email ou senha inválidos")
      end
    end

    private

    attr_reader :email, :password
  end
end
```

### Objeto Resultado (`result.rb`)

```ruby
class Result
  attr_reader :data, :errors

  def initialize(success:, data: nil, errors: nil)
    @success = success
    @data = data
    @errors = errors
  end

  def self.success(data = nil) = new(success: true, data: data)
  def self.failure(errors = nil) = new(success: false, errors: errors)

  def success? = @success
  def failure? = !@success
end
  ```

## Demonstração do Código sendo Executado

-**Execução do Código** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EQxQOfYzvb1PkV6_tcoi7QIB8uVoIhs27JhSiecKygwIJQ?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=Mn8O4j)

-**Execução do sistema de autenticação** [Link para a Gravação](https://unbbr-my.sharepoint.com/personal/221031130_aluno_unb_br/_layouts/15/stream.aspx?id=/personal/221031130_aluno_unb_br/Documents/Grava%C3%A7%C3%B5es/Reuni%C3%A3o%20com%20Caio%20Antonio%20Araujo%20Garcia%20De%20Almeida-20251024_112818-Grava%C3%A7%C3%A3o%20de%20Reuni%C3%A3o.mp4)

-**Site Rodando** [Link para a Gravação](https://unbbr-my.sharepoint.com/:v:/g/personal/190039116_aluno_unb_br/EZ_mqeuQnNtCrIodRxjNAxwB22-gXHxnpx7f3fNeHixUqw?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0NvcHkifX0&e=baG2PO)


## **Referências Bibliográficas**

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley, 1994.

> REFACTORING GURU. Strategy design pattern. Disponível em: <https://https://refactoring.guru/design-patterns/strategy>. Acesso em: 23 de outubro 2025.

---

## **Histórico de versões**

| Versão | Data       | Descrição | Autores | Revisor |
| :--- | :--- | :--- | :--- | :--- |
| 1.0 | 22/10/2025 | Criação inicial do documento e do diagrama de classes do Strategy Method | Daniel e Vinicius  |  |
| 1.1 | 23/10/2025 | Adição da parte prática inicial do Strategy | Vinicius  | Daniel |
| 1.2 | 24/10/2025 | Criação do diagrama de classes e implementação do sistema de autenticação utilizando o Command Pattern | Caio Antonio |  |